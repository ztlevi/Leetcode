{"python":"class Solution(object):\n\n    def _build(self, parent, path, paths):\n        if not parent[path[-1]]:\n            paths.append(path[:])\n            return\n        for nextWord in parent[path[-1]]:\n            path.append(nextWord)\n            self._build(parent, path, paths)\n            path.pop()\n\n    def buildLadders(self, aWord, bWord, beginWord, parent, ans):\n        paths = [[], []]\n        path = [aWord]\n        self._build(parent, path, paths[0])\n        path = [bWord]\n        self._build(parent, path, paths[1])\n        if paths[0][0][-1] != beginWord:\n            paths.reverse()\n        for path in paths[0]:\n            path.reverse()\n        for aPath in paths[0]:\n            for bPath in paths[1]:\n                ans.append(aPath + bPath)\n\n    def findLadders(self, beginWord, endWord, wordList):\n        fronts = [{beginWord}, {endWord}]\n        parent = {beginWord: None, endWord: None}\n        wordList = set(wordList)\n        wordList.discard(beginWord)\n        if endWord not in wordList:\n            return []\n        else:\n            wordList.discard(endWord)\n        ans = []\n        while fronts[0] and fronts[1] and not ans:\n            if len(fronts[0]) > len(fronts[1]):\n                fronts.reverse()\n            newLevel = set()\n            for word in fronts[0]:\n                for i in xrange(len(beginWord)):\n                    for char in string.lowercase:\n                        newWord = word[:i] + char + word[i + 1:]\n                        if newWord in fronts[1]:\n                            self.buildLadders(word, newWord, beginWord, parent, ans)\n                        if newWord in newLevel:\n                            parent[newWord].append(word)\n                        if newWord in wordList:\n                            newLevel.add(newWord)\n                            wordList.remove(newWord)\n                            parent[newWord] = [word]\n            fronts[0] = newLevel\n        return ans"}