{"python":"# Definition for an interval.\r\n# class Interval(object):\r\n#     def __init__(self, s=0, e=0):\r\n#         self.start = s\r\n#         self.end = e\r\n\r\nclass Solution(object):\r\n    def minMeetingRooms(self, intervals):\r\n        \"\"\"\r\n        :type intervals: List[Interval]\r\n        :rtype: int\r\n        \"\"\"\r\n        from heapq import *\r\n        intervals.sort(key=lambda i:i.start)\r\n        rooms = 0\r\n        pq = [] # this is the priority queue, store the rooms' endtimes\r\n        \r\n        for i in intervals:\r\n            if pq and pq[0] <= i.start:\r\n                heappop(pq) # pop the room with the earliest endtime\r\n            heappush(pq, i.end)\r\n        # the length of pq is the rooms needed\r\n        return len(pq)\r\n","java":"/**\r\n * Definition for an interval.\r\n * public class Interval {\r\n *     int start;\r\n *     int end;\r\n *     Interval() { start = 0; end = 0; }\r\n *     Interval(int s, int e) { start = s; end = e; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public int minMeetingRooms(Interval[] intervals) {\r\n        if(intervals == null || intervals.length == 0) return 0;\r\n        Arrays.sort(intervals, new Comparator<Interval>(){\r\n            public int compare(Interval i1, Interval i2){\r\n                return i1.start - i2.start;\r\n            }\r\n        });\r\n        // 用堆来管理房间的结束时间\r\n        PriorityQueue<Integer> endTimes = new PriorityQueue<Integer>();\r\n        endTimes.offer(intervals[0].end);\r\n        for(int i = 1; i < intervals.length; i++){\r\n            // 如果当前时间段的开始时间大于最早结束的时间，则可以更新这个最早的结束时间为当前时间段的结束\r\n            // 时间，如果小于的话，就加入一个新的结束时间，表示新的房间\r\n            if(intervals[i].start >= endTimes.peek()){\r\n                endTimes.poll();\r\n            }\r\n            endTimes.offer(intervals[i].end);\r\n        }\r\n        // 有多少结束时间就有多少房间\r\n        return endTimes.size();\r\n    }\r\n}"}