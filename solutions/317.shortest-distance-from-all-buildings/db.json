{"python":"class Solution(object):\n    def shortestDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or not grid[0]: return -1\n        m, n, buildings = len(grid), len(grid[0]), sum(1 for line in grid for val in line if val == 1)\n        sumDist, hit = [[0] * n for _ in range(m)], [[0] * n for _ in range(m)]\n\n        def bfs(start_x, start_y):\n            visited = [[False] * n  for _ in range(m)]\n            visited[start_x][start_y] = True\n            countBuildings = 1\n            queue = [(start_x, start_y, 0)]\n            while queue:\n                x, y, dist = queue.pop(0)\n                for i, j in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):\n                    if 0 <= i < m and 0 <= j < n and not visited[i][j]:\n                        visited[i][j] = True\n                        if not grid[i][j]:\n                            queue.append((i,j,dist+1))\n                            hit[i][j] += 1\n                            sumDist[i][j] += dist + 1\n                        elif grid[i][j] == 1:\n                            countBuildings += 1\n            return countBuildings == buildings\n\n        for x in range(m):\n            for y in range(n):\n                if grid[x][y] == 1:\n                    reachable = bfs(x, y)\n                    if not reachable:\n                        return -1\n        minSum = float('inf')\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and hit[i][j] == buildings:\n                    minSum = min(minSum, sumDist[i][j])\n        return minSum if minSum < float('inf') else -1\n                    \n# so = Solution()\n# so.shortestDistance([[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]])\n"}