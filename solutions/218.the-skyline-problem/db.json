{"java":"class Height {\r\n    int index;\r\n    int height;\r\n    Height(int index, int height) {\r\n        this.index = index;\r\n        this.height = height;\r\n    }\r\n}\r\n\r\npublic class Solution {\r\n    public List<int[]> getSkyline(int[][] buildings) {\r\n        List<int[]> result = new ArrayList<int[]>();\r\n        if(buildings.length == 0 || buildings[0].length == 0) return result; \r\n\r\n        List<Height> heights = new ArrayList<Height>();\r\n        for(int[] building : buildings) {\r\n            heights.add(new Height(building[0], -building[2]));\r\n            heights.add(new Height(building[1], building[2]));\r\n        }\r\n\r\n        Collections.sort(heights, new Comparator<Height>(){\r\n                @Override\r\n                public int compare(Height h1, Height h2) {\r\n                    return h1.index != h2.index ? h1.index - h2.index : h1.height - h2.height;\r\n                }\r\n            });\r\n        \r\n        // use reverseOrder so that the lager one get the higher priority, 1000 is the init capacity\r\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(1000, Collections.reverseOrder());\r\n        pq.offer(0);\r\n        int prev = 0;\r\n        for (Height h : heights) {\r\n            if(h.height < 0) {\r\n                pq.offer(-h.height);\r\n            } else {\r\n                pq.remove(h.height);\r\n            }\r\n            int cur = pq.peek();\r\n            if (cur !=  prev) {\r\n                result.add(new int[]{h.index, cur});\r\n                prev = cur;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    \r\n}"}