{"python":"# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger(object):\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\n\nclass NestedIterator(object):\n\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        self.flattenList = []\n        self.idx = 0\n        self.flatten(nestedList)\n    \n    def flatten(self, nestedList):\n        for i in nestedList:\n            if i.isInteger():\n                self.flattenList.append(i.getInteger())\n            else:\n                self.flatten(i.getList())\n                \n            \n\n    def next(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        rst = self.flattenList[self.idx]\n        self.idx += 1\n        return rst\n\n    def hasNext(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if self.idx < len(self.flattenList):\n            return True\n        \n\n# Your NestedIterator object will be instantiated and called as such:\n# i, v = NestedIterator(nestedList), []\n# while i.hasNext(): v.append(i.next())\n"}